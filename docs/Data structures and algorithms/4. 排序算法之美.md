# 排序算法之美
[排序算法动态图](https://visualgo.net/en/sorting)
# 如何分析**排序算法**

## 排序算法的好坏 <!-- {docsify-ignore} -->
从这几个方面来衡量
+ 最好情况、最坏情况、平均情况时间复杂度
+ 时间复杂度的系数、常数、低阶
+ 比较次数和交换（或移动）次数

## 排序算法的内存消耗 <!-- {docsify-ignore} -->

可以使用空间复杂度来衡量

原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法.

## 排序算法的稳定性 <!-- {docsify-ignore} -->

这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

```
我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。

经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。
```
稳定性有什么作用呢

问题:比如10万条订单数据,需要按照金额从小到大排序,订单金额一致的按照订单创建时间排序

解决一:使用两步排序的方法,先使用金额排序,在使用时间排序

解决二:使用稳定性的排序算法,先按照订单下单的时间排序,排序完成之后再按照订单金额排序.**稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。**.为什么说这种方案比上一种好呢,因为一般我们存储在数据库的数据都有时间来进行排序,所以其实第一步先进行时间排序,真实的场景并不会变更很多数据,所以对资源的消耗要小一些.



# 冒泡排序

原理:
+ 冒泡排序只会操作相邻的两个数据。
+ 如何左边大于右边,就进行更换位置.直到没有需要更换的为止


[](https://pic1.zhimg.com/v2-43dc4f02286be372415bec478a227940_b.webp)

代码实现
```java
    public static void main(String[] args) {
        SortTest sortTest = new SortTest();
        int[] array = {
                4, 2, 5, 1, 6, 3
        };
        System.out.println("开始时array:");
        sortTest.printArray(array);
        sortTest.bubbling2(array);
        System.out.println("结束时array:");
        sortTest.printArray(array);
    }


    public void bubbling(int[] array) {
        int count = 0;
        //冒泡排序
        System.out.println("开始排序");
        while (true) {
            //截止条件是顺序不进行更换
            boolean flag = false;
            for (int i = 0; i < array.length - 1; i++) {
                count++;
                if (array[i] > array[i + 1]) {
                    int tmp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = tmp;
                    flag = true;
                }
            }
            if (!flag) {
                break;
            }
        }
        System.out.println("执行次数：" + count);
    }

    public void printArray(int[] array) {
        for (int a : array) { System.out.print(a + ","); }
    }
    
    //优化点
    //1. 每轮执行结束之后，最后都会有一个最大的值会固定为止，比如253614。第一轮执行完成之后6就会被固定到最后的位置，第二轮执行完成之后5就会固定到除了6之外最后的位置。所以比较次数，一次会比一次少。所以可以优化成以下情况
    //2. 按照上面说法，最大执行的次数就是数组大小的次数。
    public void bubbling2(int[] array) {
        int count = 0;

        for (int i = 0; i < array.length; i++) {
            boolean flag = false;
            for (int j = 0; j < array.length - i - 1; j++) {
                count++;
                //-i是因为优化点
                //-1是因为数组最后一个元素没有其他元素可以与他比较了
                if (array[j] > array[j + 1]) {
                    int tmp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tmp;
                    flag = true;
                }
            }
            if (!flag) {
                break;
            }
        }
        System.out.println("执行次数：" + count);
    }
```


特性:
1. 冒泡排序是原地排序算法
   冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
2. 冒泡排序是稳定的排序算法
   在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
3. 时间复杂度
   最好情况(1,2,3,4,5,6),时间复杂度是O(n)<br/>
   最坏情况(6,5,4,3,2,1),时间复杂度是O(n^2)
   平均时间复杂度O(n^2)

# 插入排序

一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。

插入排序的操作
1. 元素的比较
2. 元素的移动

原理: 借鉴至
![](https://www.cnblogs.com/nicaicai/p/12596565.html)

1. 确定到需要插入的值
2. 将值与已排序的数组进行比较
3. 值比较小就将被比较的值向后移动一次(这个时候a[j]=a[j+1])
4. 直到找到需要插入的值之后将值赋值给a[j]=val即可
代码:

```java
// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

代码几个要点:
1. i从1开始比较
2. j=i-1
3. j从大向小进行--操作

特性:
1. 插入排序是原地排序算法
2. 插入排序是稳定的排序算法
3. 插入排序的时间复杂度
   最好是时间复杂度为 O(n)
   最坏是O(n^2)
   平均是O(n^2)对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作

# 选择排序
![](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

选择排序也是将数据分成“已排序”和“未排序”.每次都从未排序中获取最小的值,将其放在已排序的末尾.(交换已排序的末尾后面的数值)

特性:
1. 是原地排序算法
2. 不稳定,因为每次都会进行数据交换,会将前面的数据交换到后面,所以不稳定
3. 空间复杂度是O(1),最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)



![总结](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)

#  附

**1. 为什么插入排序比冒泡排序要好**

从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。
```java

冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```