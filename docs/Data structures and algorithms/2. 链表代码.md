# 链表代码
# 1. 技巧

## 1.1 技巧一: 理解指针和引用的概念

指针(C、C++、Go)和引用(python、java)的含义都是**存储所指对象的内存地址**

**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**

```
在编写链表代码的时候，我们经常会有这样的代码：p->next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。

还有一个更复杂的，也是我们写链表代码经常会用到的：p->next=p->next->next。这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。
```

## 1.2 技巧二:警惕指针丢失和内存泄露

我们插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。

![](https://static001.geekbang.org/resource/image/05/6e/05a4a3b57502968930d517c934347c6e.jpg)
比如这个,如果将a的next指针中存储了x的内存地址,那么这个时候a的next指针就无法找到b了,所以就不能在使用这条x线了


## 1.3 技巧三:使用哨兵简化实现难度

**链表的插入操作**
```
new_node->next=p->next

p-next->new_node

1. 标识一个新的节点的next指针中存储p的next内存地址(这个时候p->next和now_node->nex都是存储了同一个内存地址,指向同一个值)
2. 将new_node的内存地址用p-next存储在,这个时候就相当于p-next=new_node、new_node->下一个节点
这样就实现了节点的插入操作
```

**链表首插入一个节点**
```
if (head == null) {
  head = new_node;
}
```

**链表删除一个节点**

```
p->next = p->next->next;
```

**删除最后一个节点**

```
if (head->next == null) {
   head = null;
}
```

所以哨兵其实就是为了解决这种**边界问题**的

原理就是,在每个链表头部都增加一个节点**哨兵节点**,这个哨兵节点并不存储任何数据,只是放在那.这样所有的插入和删除操作就可以统一使用一套代码实现了

## 1.4 技巧四:重点处理边界条件

我经常用来检查链表代码是否正确的边界条件有这样几个：
1. 如果链表为空时，代码是否能正常工作？
2. 如果链表只包含一个结点时，代码是否能正常工作？
3. 如果链表只包含两个结点时，代码是否能正常工作？
4. 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？


## 1.5 技巧五:举例画图,辅助思考

